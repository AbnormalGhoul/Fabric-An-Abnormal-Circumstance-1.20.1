package net.abnormal.anabnormalcircumstance.mixin;

import net.abnormal.anabnormalcircumstance.effect.ModEffects;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.damage.DamageSource;
import net.minecraft.entity.effect.StatusEffectInstance;
import net.minecraft.registry.tag.DamageTypeTags;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

@Mixin(LivingEntity.class)
public abstract class LivingEntityVulnerabilityMixin {

    @Inject(
            method = "modifyAppliedDamage",
            at = @At("RETURN"),
            cancellable = true
    )
    private void applyVulnerability(
            DamageSource source,
            float amount,
            CallbackInfoReturnable<Float> cir
    ) {
        LivingEntity self = (LivingEntity)(Object)this;

        // Mirror vanilla exclusions
        if (source.isIn(DamageTypeTags.BYPASSES_EFFECTS)) return;

        StatusEffectInstance vuln = self.getStatusEffect(ModEffects.VULNERABILITY);
        if (vuln == null) return;

        // Optional: respect BYPASSES_RESISTANCE like Resistance does
        if (source.isIn(DamageTypeTags.BYPASSES_RESISTANCE)) return;

        int level = vuln.getAmplifier() + 1;

        /*
         * Vanilla Resistance:
         * i = level * 5
         * j = 25 - i
         * amount = amount * j / 25
         *
         * That is: -20% per level
         *
         * Reversed Vulnerability:
         * +20% per level
         */

        int i = level * 5;
        int j = 25 + i; // reversed

        float original = cir.getReturnValue();
        float increased = original * (float) j / 25.0F;

        cir.setReturnValue(increased);
    }
}
